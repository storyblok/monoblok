#!/usr/bin/env tsx

import { execSync } from 'child_process';
import { writeFileSync, readFileSync, existsSync, mkdirSync, rmSync } from 'fs';
import { join, dirname, basename } from 'path';
import { glob } from 'glob';
import { createClient } from '@hey-api/openapi-ts';
import Mustache from 'mustache';
import { camelCase, pascalCase } from 'change-case';

interface OpenApiPackage {
  path: string;
}

async function main() {

  rmSync('src/generated', { recursive: true, force: true })

  try {
    // Get OpenAPI package path
    const openapiListOutput = execSync('pnpm --filter @storyblok/openapi list --json', { encoding: 'utf8' });
    const openapiPackages: OpenApiPackage[] = JSON.parse(openapiListOutput);
    const OPENAPI_PATH = openapiPackages[0].path;

    // Find all yaml files in the resources folder
    const yamlFiles = await glob('dist/*.yaml', { cwd: OPENAPI_PATH });
    
    if (yamlFiles.length === 0) {
      console.log('No YAML files found in OpenAPI dist folder');
      return;
    }

    const generatedSdks: string[] = [];

    // Generate a client for each resource
    for (const yamlFile of yamlFiles) {
      const resourcePath = join(OPENAPI_PATH, yamlFile);
      const resourceName = basename(yamlFile, '.yaml')
    
      await createClient({
        input: resourcePath,
        output: `src/generated/${resourceName}`,
        plugins: [
           {
            enums: 'javascript',
            name: '@hey-api/typescript',
          },
          {
            name: '@hey-api/client-fetch',
          },
          {
            asClass: true,
            instance: true,
            name: '@hey-api/sdk',
          }
        ]
      })

      generatedSdks.push(resourceName);
    }

    // Generate single SDK registry file
    console.log('Generating SDK registry...');
    
    const formattedContent = generateRegistryContent(generatedSdks);
    
    // Ensure src directory exists
    const srcDir = 'src';
    if (!existsSync(srcDir)) {
      mkdirSync(srcDir, { recursive: true });
    }
    
    writeFileSync(join(srcDir, 'sdk-registry.generated.ts'), formattedContent);
    
    console.log(`Generated SDK registry with ${generatedSdks.length} SDKs: ${generatedSdks.join(', ')}`);
    
  } catch (error) {
    console.error('Build failed:', error);
    process.exit(1);
  }
}

function generateRegistryContent(generatedSdks: string[]): string {
  const template = `// Auto-generated SDK registry
// This file is generated by build.ts - do not edit manually

// Import all generated SDKs
{{#generatedSdks}}
import { Sdk as {{className}}Sdk } from './generated/{{originalName}}/sdk.gen';
{{/generatedSdks}}

// Export all SDKs for grouped imports
{{#generatedSdks}}
export { {{className}}Sdk };
{{/generatedSdks}}

// Registry object for dynamic access
export const sdkRegistry = {
{{#generatedSdks}}
  '{{propertyName}}': {{className}}Sdk,
{{/generatedSdks}}
} as const;

export type SdkRegistryInstance = {
  [K in keyof SdkRegistry]: InstanceType<SdkRegistry[K]>;
}

// Type for the registry
export type SdkRegistry = typeof sdkRegistry;

// Helper to get available SDK names
export const getAvailableSdks = () => Object.keys(sdkRegistry);
`;

  return Mustache.render(template, { 
    generatedSdks: generatedSdks.map(sdk => ({
      originalName: sdk,
      className: pascalCase(sdk),
      propertyName: camelCase(sdk)
    }))
  });
}

main().catch(console.error); 
