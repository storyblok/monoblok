import { generateStoryblokTypes, generateTypes, getComponentType, getStoryType, saveConsolidatedTypeFile, saveSeparateTypeFiles } from './actions';
import { vol } from 'memfs';
import { readFileSync } from 'node:fs';
import { join, resolve } from 'node:path';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import type { SpaceComponent, SpaceComponentsData } from '../../../commands/components/constants';
import type { GenerateTypesOptions } from './constants';

import { saveToFile } from '../../../utils/filesystem';

// Mock the filesystem module
vi.mock('../../../utils/filesystem', async (importOriginal) => {
  const actual = await importOriginal<typeof import('../../../utils/filesystem')>();
  return {
    sanitizeFilename: actual.sanitizeFilename,
    saveToFile: vi.fn().mockResolvedValue(undefined),
    resolvePath: vi.fn().mockReturnValue('/mocked/resolved/path'),
  };
});

// Mock the fs module
vi.mock('node:fs', () => ({
  readFileSync: vi.fn().mockReturnValue(''),
}));

vi.mock('node:fs/promises');
vi.mock('node:path', () => ({
  resolve: vi.fn().mockReturnValue('/mocked/path'),
  join: vi.fn().mockReturnValue('/mocked/joined/path'),
}));

// Create a mock for the custom fields parser
const mockCustomFieldsParser = vi.fn().mockImplementation((key, field) => {
  if (field.field_type === 'native-color-picker') {
    return {
      [key]: {
        properties: {
          color: { type: 'string' },
        },
        required: ['color'],
        type: 'object',
      },
    };
  }
  return {};
});

// Mock the dynamic import
vi.mock('/mocked/path', () => ({
  default: mockCustomFieldsParser,
}));

// Mock the import function
vi.mock('node:module', () => ({
  import: vi.fn().mockResolvedValue({
    default: mockCustomFieldsParser,
  }),
}));

// Set up the virtual file system with our custom fields parser
vol.fromJSON({
  '/path/to/custom/parser.ts': `
export default (key: string, field: any) => {
  switch (field.field_type) {
    case 'native-color-picker':
      return {
        [key]: {
          properties: {
            color: { type: 'string' },
          },
          required: ['color'],
          type: 'object',
        },
      };
    default:
      return {};
  }
};
`,
  // Add a mock storyblok.ts file for testing generateStoryblokTypes
  '/mocked/path': `
// Storyblok types
export type StoryblokPropertyType = 'text' | 'textarea' | 'number' | 'boolean' | 'multilink' | 'bloks' | 'custom';

export interface StoryblokText {
  type: 'text';
  required?: boolean;
}

export interface StoryblokTextarea {
  type: 'textarea';
  required?: boolean;
}

export interface StoryblokNumber {
  type: 'number';
  required?: boolean;
}

export interface StoryblokBoolean {
  type: 'boolean';
  required?: boolean;
}

export interface StoryblokMultilink {
  type: 'multilink';
  required?: boolean;
  email_link_type?: boolean;
  asset_link_type?: boolean;
}

export interface StoryblokBloks {
  type: 'bloks';
  required?: boolean;
  restrict_components?: boolean;
  component_whitelist?: string[];
  component_group_whitelist?: string[];
  component_tag_whitelist?: number[];
  restrict_type?: 'groups' | 'components' | 'tags';
}

export interface StoryblokCustom {
  type: 'custom';
  required?: boolean;
  field_type?: string;
}
`,
});

// Set up the mock content for readFileSync
const mockStoryblokContent = vol.readFileSync('/mocked/path', 'utf-8') as string;
vi.mocked(readFileSync).mockImplementation((path) => {
  if (path === '/mocked/path') {
    return mockStoryblokContent;
  }
  return '';
});

const mockSpaceData: SpaceComponentsData = {
  components: [
    {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        title: {
          type: 'text',
          required: true,
        },
        description: {
          type: 'textarea',
          required: false,
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    },
  ],
  datasources: [],
  groups: [],
  presets: [],
  internalTags: [],
};

describe('generate types actions', () => {
  it('should generate types successfully', async () => {
    // Create mock options
    const mockOptions: GenerateTypesOptions = {
      strict: false,
    };

    // Call the function with the correct parameters
    const result = await generateTypes(mockSpaceData, mockOptions);

    // Verify the result contains expected content
    expect(result).toContain('// This file was generated by the storyblok CLI.');
    expect(result).toContain('// DO NOT MODIFY THIS FILE BY HAND.');
    expect(result).toContain('export interface TestComponent');
    expect(result).toContain('title: string');
    expect(result).toContain('description?: string');
    expect(result).toContain('component: "test_component"');
    expect(result).toContain('_uid: string');
    expect(result).toContain('[k: string]: unknown');
  });

  it('should generate types successfully with strict mode', async () => {
    const mockOptions: GenerateTypesOptions = {
      strict: true,
    };

    const result = await generateTypes(mockSpaceData, mockOptions);

    expect(result).not.toContain('[k: string]: unknown');
  });

  it('should handle customFieldsParser option', async () => {
    // Create mock options with customFieldsParser
    const mockOptions: GenerateTypesOptions = {
      strict: false,
      customFieldsParser: '/path/to/custom/parser.ts',
    };

    // Call the function with the customFieldsParser option
    const result = await generateTypes(mockSpaceData, mockOptions);

    // Verify that the result is generated successfully
    expect(result).toBeDefined();
    if (result) {
      expect(typeof result).toBe('string');
      expect(result.length).toBeGreaterThan(0);
    }

    // Verify that resolve was called with the customFieldsParser path
    expect(resolve).toHaveBeenCalledWith('/path/to/custom/parser.ts');
  });

  it('should handle compilerOptions option', async () => {
    // Create mock options with compilerOptions
    const mockOptions: GenerateTypesOptions = {
      strict: false,
      compilerOptions: '/path/to/compiler/options',
    };

    // Call the function with the compilerOptions option
    const result = await generateTypes(mockSpaceData, mockOptions);

    // Verify that the result is generated successfully
    expect(result).toBeDefined();
    if (result) {
      expect(typeof result).toBe('string');
      expect(result.length).toBeGreaterThan(0);
    }

    // Verify that resolve was called with the compilerOptions path
    expect(resolve).toHaveBeenCalledWith('/path/to/compiler/options');
  });

  it('should apply typePrefix to component type names', async () => {
    // Create mock options with typePrefix
    const mockOptions: GenerateTypesOptions = {
      strict: false,
      typePrefix: 'Custom',
    };

    // Call the function with the typePrefix option
    const result = await generateTypes(mockSpaceData, mockOptions);

    // Verify that the result contains the expected prefixed type name
    expect(result).toContain('export interface CustomTestComponent');
    expect(result).toContain('title: string');
    expect(result).toContain('description?: string');
    expect(result).toContain('component: "test_component"');
    expect(result).toContain('_uid: string');
    expect(result).toContain('[k: string]: unknown');
  });
});

describe('getComponentType', () => {
  it('should convert component name to PascalCase', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('test_component', options)).toBe('TestComponent');
  });

  it('should handle special characters in component name', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('test-component!', options)).toBe('TestComponent');
  });

  it('should handle emojis in component name', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('testðŸ˜€component', options)).toBe('TestComponent');
  });

  it('should handle multiple consecutive special characters', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('test___component', options)).toBe('TestComponent');
  });

  it('should handle component names starting with numbers', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('123component', options)).toBe('_123component');
  });

  it('should apply typePrefix when provided', () => {
    const options: GenerateTypesOptions = {
      typePrefix: 'Custom',
    };
    expect(getComponentType('test_component', options)).toBe('CustomTestComponent');
  });

  it('should handle empty typePrefix', () => {
    const options: GenerateTypesOptions = {
      typePrefix: '',
    };
    expect(getComponentType('test_component', options)).toBe('TestComponent');
  });

  it('should apply typeSuffix when provided', () => {
    const options: GenerateTypesOptions = {
      typeSuffix: 'CustomSuffixValue',
    };
    expect(getComponentType('test_component', options)).toBe('TestComponentCustomSuffixValue');
  });

  it('should handle empty typeSuffix', () => {
    const options: GenerateTypesOptions = {
      typeSuffix: '',
    };
    expect(getComponentType('test_component', options)).toBe('TestComponent');
  });

  it('should handle component names with spaces', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('test component', options)).toBe('TestComponent');
  });
});

describe('getStoryType', () => {
  it('should convert property names to the correct format', () => {
    // Test cases for different property name formats
    expect(getStoryType('my_property')).toBe('ISbStoryData<MyProperty>');
    expect(getStoryType('my-property')).toBe('ISbStoryData<MyProperty>');
    expect(getStoryType('myProperty')).toBe('ISbStoryData<MyProperty>');
    expect(getStoryType('MyProperty')).toBe('ISbStoryData<MyProperty>');
    expect(getStoryType('my property')).toBe('ISbStoryData<MyProperty>');
    expect(getStoryType('my_property_name')).toBe('ISbStoryData<MyPropertyName>');
  });

  it('should handle special characters and numbers', () => {
    expect(getStoryType('my_property_123')).toBe('ISbStoryData<MyProperty123>');
    expect(getStoryType('my-property!')).toBe('ISbStoryData<MyProperty>');
    expect(getStoryType('my_property@name')).toBe('ISbStoryData<MyPropertyName>');
  });

  it('should handle empty or single character properties', () => {
    expect(getStoryType('')).toBe('ISbStoryData<>');
    expect(getStoryType('a')).toBe('ISbStoryData<A>');
  });

  it('should handle prefix', () => {
    expect(getStoryType('my_property', 'Custom')).toBe('ISbStoryData<CustomMyProperty>');
  });
});

describe('component property type annotations', () => {
  it('should handle text property type', async () => {
    // Create a component with text property type
    const componentWithTextType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        title: {
          type: 'text',
          required: true,
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceComponentsData = {
      components: [componentWithTextType],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('title: string');
  });

  it('should handle textarea property type', async () => {
    // Create a component with textarea property type
    const componentWithTextareaType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        description: {
          type: 'textarea',
          required: false,
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceComponentsData = {
      components: [componentWithTextareaType],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('description?: string');
  });

  it('should handle number property type', async () => {
    // Create a component with number property type
    const componentWithNumberType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        count: {
          type: 'number',
          required: false,
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceComponentsData = {
      components: [componentWithNumberType],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('count?: string');
  });

  it('should handle boolean property type', async () => {
    // Create a component with boolean property type
    const componentWithBooleanType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        isActive: {
          type: 'boolean',
          required: false,
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceComponentsData = {
      components: [componentWithBooleanType],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('isActive?: boolean');
  });

  it('should handle multilink property type', async () => {
    const componentWithMultilinkEmail: SpaceComponent = {
      name: 'test_component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        link: {
          type: 'multilink',
          required: false,
          email_link_type: true,
          asset_link_type: false,
        },
      },
    };
    const spaceData1: SpaceComponentsData = {
      components: [componentWithMultilinkEmail],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };
    expect(await generateTypes(spaceData1, { strict: false }))
      .toContain('link?: Exclude<StoryblokMultilink, {linktype?: "asset"}>;');

    const componentWithMultilinkBoth: SpaceComponent = {
      name: 'test_component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        link: {
          type: 'multilink',
          required: false,
          email_link_type: true,
          asset_link_type: true,
        },
      },
    };
    const spaceData2: SpaceComponentsData = {
      components: [componentWithMultilinkBoth],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };
    expect(await generateTypes(spaceData2, { strict: false }))
      .toContain('link?: StoryblokMultilink;');

    const componentWithMultilinkNone: SpaceComponent = {
      name: 'test_component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        link: {
          type: 'multilink',
          required: false,
          email_link_type: false,
          asset_link_type: false,
        },
      },
    };
    const spaceData3: SpaceComponentsData = {
      components: [componentWithMultilinkNone],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };
    expect(await generateTypes(spaceData3, { strict: false }))
      .toContain('link?: Exclude<StoryblokMultilink, {linktype?: "email"} | {linktype?: "asset"}>;');
  });

  it('should handle bloks property type with component restrictions', async () => {
    // Create a component with bloks property type and component restrictions
    const componentWithBloksType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        content: {
          type: 'bloks',
          required: false,
          restrict_components: true,
          component_whitelist: ['button', 'image'],
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceComponentsData = {
      components: [componentWithBloksType],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('content?:');
  });

  it('should handle bloks property type with tag-based restrictions', async () => {
    // Create components with different tag IDs
    const buttonComponent: SpaceComponent = {
      name: 'button',
      display_name: 'Button',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {},
      internal_tags_list: [],
      internal_tag_ids: ['1', '2'], // Has tags 1 and 2
    };

    const imageComponent: SpaceComponent = {
      name: 'image',
      display_name: 'Image',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 2,
      schema: {},
      internal_tags_list: [],
      internal_tag_ids: ['2', '3'], // Has tags 2 and 3
    };

    const textComponent: SpaceComponent = {
      name: 'text',
      display_name: 'Text',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 3,
      schema: {},
      internal_tags_list: [],
      internal_tag_ids: ['4'], // Has tag 4 only
    };

    // Create a component with bloks property type and tag-based restrictions
    const componentWithTagBasedBloks: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 4,
      schema: {
        content: {
          type: 'bloks',
          required: false,
          restrict_components: true,
          restrict_type: 'tags',
          component_tag_whitelist: [1, 2], // Only allow components with tags 1 or 2
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with these components
    const spaceData: SpaceComponentsData = {
      components: [buttonComponent, imageComponent, textComponent, componentWithTagBasedBloks],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected union type for tag-based restrictions
    // Should include Button and Image (both have tags 1 or 2), but not Text (only has tag 4)
    expect(result).toContain('content?:');
    expect(result).toContain('(Button | Image)[]');
  });

  it('should handle tabbed properties correctly', async () => {
    // Create a component with tabbed properties
    const componentWithTabbedProperties: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        'tab-content': {
          type: 'tab',
          display_name: 'Content',
        },
        'title': {
          type: 'text',
          required: true,
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceComponentsData = {
      components: [componentWithTabbedProperties],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type but not the tab
    expect(result).toContain('title: string');
    expect(result).not.toContain('tab-content');
  });

  it('should handle custom property type with customFieldsParser', async () => {
    // Create a component with custom property type
    const componentWithCustomType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        colorPicker: {
          type: 'custom',
          field_type: 'native-color-picker',
          required: false,
        },
      },
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceComponentsData = {
      components: [componentWithCustomType],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Create mock options with customFieldsParser
    const mockOptions: GenerateTypesOptions = {
      strict: false,
      customFieldsParser: '/path/to/custom/parser.ts',
    };

    // Reset the mock to ensure it's called with the right parameters
    mockCustomFieldsParser.mockClear();

    // Generate types
    const result = await generateTypes(spaceData, mockOptions);

    // Verify that the custom fields parser was called
    expect(mockCustomFieldsParser).toHaveBeenCalled();

    // Verify that the result contains the expected property type
    expect(result).toContain('colorPicker?:');
    expect(result).toContain('color: string');
  });
});

describe('generateStoryblokTypes', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should generate Storyblok types successfully with default options', async () => {
    // Call the function with default options
    const result = await generateStoryblokTypes();

    // Verify that the function returns true
    expect(result).toBe(true);

    // Verify that readFileSync was called with the correct path
    expect(readFileSync).toHaveBeenCalledWith('/mocked/path', 'utf-8');
    expect(join).toHaveBeenCalledWith(expect.any(String), 'storyblok.d.ts');

    // Verify that saveToFile was called with the correct parameters
    const savedContent = vi.mocked(saveToFile).mock.calls[0][1];
    const lines = savedContent.split('\n');

    // Verify the first three lines
    expect(lines[0]).toBe('// This file was generated by the Storyblok CLI.');
    expect(lines[1]).toBe('// DO NOT MODIFY THIS FILE BY HAND.');
    expect(lines[2]).toBe('import type { ISbStoryData } from \'@storyblok/js\';');
  });

  it('should generate Storyblok types with custom path', async () => {
    // Call the function with custom path
    const result = await generateStoryblokTypes({ path: '/custom/path' });

    // Verify that the function returns true
    expect(result).toBe(true);

    // Verify that resolve was called with the correct path
    expect(resolve).toHaveBeenCalledWith(expect.any(String), '/custom/path', 'types');
  });

  it('should extract all Storyblok type definitions', async () => {
    // Call the function
    await generateStoryblokTypes();

    // Get the content passed to saveToFile
    const savedContent = vi.mocked(saveToFile).mock.calls[0][1];

    // Verify that all expected type definitions are included
    expect(savedContent).toContain('export type StoryblokPropertyType = \'text\' | \'textarea\' | \'number\' | \'boolean\' | \'multilink\' | \'bloks\' | \'custom\';');
    expect(savedContent).toContain('export interface StoryblokText');
    expect(savedContent).toContain('export interface StoryblokTextarea');
    expect(savedContent).toContain('export interface StoryblokNumber');
    expect(savedContent).toContain('export interface StoryblokBoolean');
    expect(savedContent).toContain('export interface StoryblokMultilink');
    expect(savedContent).toContain('export interface StoryblokBloks');
    expect(savedContent).toContain('export interface StoryblokCustom');
  });
});

describe('separate files mode', () => {
  it('should return an array of separate type files when options.separateFiles is true', async () => {
    const spaceData: SpaceComponentsData = {
      components: [
        {
          name: 'Hero Section X',
          display_name: 'Hero',
          created_at: '2023-01-01T00:00:00Z',
          updated_at: '2023-01-01T00:00:00Z',
          id: 1,
          schema: {
            title: { type: 'text', required: true },
          },
          internal_tags_list: [],
          internal_tag_ids: [],
        },
        {
          name: 'cta-button',
          display_name: 'CTA Button',
          created_at: '2023-01-01T00:00:00Z',
          updated_at: '2023-01-01T00:00:00Z',
          id: 2,
          schema: {
            href: { type: 'multilink', required: false, email_link_type: true, asset_link_type: true },
          },
          internal_tags_list: [],
          internal_tag_ids: [],
        },
      ],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    const result = await generateTypes(spaceData, { separateFiles: true, strict: false });
    expect(Array.isArray(result)).toBe(true);
    const files = result as { name: string; content: string }[];
    expect(files).toHaveLength(2);

    expect(files[0].content).toContain('// This file was generated by the storyblok CLI.');
    expect(files[0].content).toContain('// DO NOT MODIFY THIS FILE BY HAND.');
    expect(files[0].name).toBe('Hero Section X');
    expect(files[0].content.includes('export interface HeroSectionX')).toBe(true);
    expect(files[1].name).toBe('cta-button');
    expect(files[1].content.includes('export interface CtaButton')).toBe(true);
  });

  it('should scope Storyblok imports per file (only files that need Multilink import should have it)', async () => {
    const withMultilink: SpaceComponent = {
      name: 'link-card',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        link: { type: 'multilink', required: false, email_link_type: true, asset_link_type: true },
      },
    };

    const simpleText: SpaceComponent = {
      name: 'plain-text',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 2,
      schema: {
        text: { type: 'text', required: false },
      },
    };

    const spaceData: SpaceComponentsData = {
      components: [withMultilink, simpleText],
      datasources: [],
      groups: [],
      presets: [],
      internalTags: [],
    };

    const files = await generateTypes(spaceData, { separateFiles: true, strict: false });
    if (!Array.isArray(files)) {
      throw new TypeError(`generateTypes didn't return an array`);
    }

    const fileWith = files.find(f => f.name.includes('link-card') || f.content.includes('export interface LinkCard'));
    const fileWithout = files.find(f => f.name.includes('plain-text') || f.content.includes('export interface PlainText'));

    expect(fileWith).toBeDefined();
    expect(fileWithout).toBeDefined();

    // Multilink import only in the file that needs it
    expect(fileWith!.content).toMatch(/import type \{ StoryblokMultilink \} from '\.\.\/storyblok\.d\.ts';/);
    expect(fileWithout!.content).not.toMatch(/import type \{ StoryblokMultilink \} from '\.\.\/storyblok\.d\.ts';/);
  });
});

describe('saveConsolidatedTypeFile', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should write a single file with default filename', async () => {
    const dummyTypes = '// types content';
    await saveConsolidatedTypeFile('12345', dummyTypes, '/some/path');

    expect(join).toHaveBeenCalledWith(expect.any(String), 'storyblok-components.d.ts');
    expect(saveToFile).toHaveBeenCalledWith('/mocked/joined/path', dummyTypes);
  });

  it('should write a single file with custom filename', async () => {
    const dummyTypes = '// types content';
    const customFilename = 'my-custom-types';

    await saveConsolidatedTypeFile('12345', dummyTypes, '/some/path', customFilename);

    expect(join).toHaveBeenCalledWith(expect.any(String), `${customFilename}.d.ts`);
    expect(saveToFile).toHaveBeenCalledWith('/mocked/joined/path', dummyTypes);
  });
});

describe('saveSeparateTypeFiles', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should write one file per component', async () => {
    const files = [
      { name: 'Hero', content: '// hero' },
      { name: 'Button', content: '// button' },
    ];

    await saveSeparateTypeFiles('12345', files, '/some/path');

    expect(saveToFile).toHaveBeenCalledTimes(2);
    expect(join).toHaveBeenCalledWith(expect.any(String), 'Hero.d.ts');
    expect(join).toHaveBeenCalledWith(expect.any(String), 'Button.d.ts');
    expect(saveToFile).toHaveBeenCalledWith('/mocked/joined/path', '// hero');
    expect(saveToFile).toHaveBeenCalledWith('/mocked/joined/path', '// button');
  });
});
